<!DOCTYPE html>
<html>
<head>
  <title>JNTUH Campus Map</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body, html { margin: 0; padding: 0; height: 100%; }
    #map { width: 100%; height: 100vh; }
  </style>
</head>
<body>

  <div id="map"></div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
  const map = L.map('map').setView([17.49315, 78.3915], 17);

  // Base map
  L.tileLayer('https://{s}.tile.osm.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  // 📍 Start location (Default GPS-based, Main Gate)
  const defaultStart = [17.49315, 78.3915];

  // Mark start point
  const startMarker = L.marker(defaultStart, {
    icon: L.icon({
      iconUrl: 'https://cdn-icons-png.flaticon.com/512/64/64113.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41]
    })
  }).addTo(map).bindPopup("Default Start").openPopup();

  // Define allowed junction points (nodes)
  const nodes = {
    "Main Gate": [17.49315, 78.3915],
    "Library": [17.49485, 78.3922],
    "Admin": [17.4942, 78.3911]
  };

  // Define graph with distances
  const graph = {
    "17.49315,78.3915": {
      "17.49485,78.3922": getDistance(17.49315, 78.3915, 17.49485, 78.3922),
      "17.4942,78.3911": getDistance(17.49315, 78.3915, 17.4942, 78.3911)
    },
    "17.49485,78.3922": {
      "17.49315,78.3915": getDistance(17.49485, 78.3922, 17.49315, 78.3915),
      "17.4942,78.3911": getDistance(17.49485, 78.3922, 17.4942, 78.3911)
    },
    "17.4942,78.3911": {
      "17.49315,78.3915": getDistance(17.4942, 78.3911, 17.49315, 78.3915),
      "17.49485,78.3922": getDistance(17.4942, 78.3911, 17.49485, 78.3922)
    }
  };

  // Draw node markers
  Object.values(nodes).forEach((coords) => {
    L.circleMarker(coords, { radius: 5, color: 'red' }).addTo(map);
  });

  // Haversine
  function getDistance(lat1, lon1, lat2, lon2) {
    const R = 6371e3;
    const φ1 = lat1 * Math.PI / 180;
    const φ2 = lat2 * Math.PI / 180;
    const Δφ = (lat2 - lat1) * Math.PI / 180;
    const Δλ = (lon2 - lon1) * Math.PI / 180;

    const a = Math.sin(Δφ / 2) ** 2 +
              Math.cos(φ1) * Math.cos(φ2) *
              Math.sin(Δλ / 2) ** 2;
    return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
  }

  // Dijkstra algorithm
  function dijkstra(start, end) {
    const distances = {}, prev = {}, queue = new Set(Object.keys(graph));

    Object.keys(graph).forEach(n => {
      distances[n] = Infinity;
      prev[n] = null;
    });
    distances[start] = 0;

    while (queue.size) {
      let curr = [...queue].reduce((a, b) => distances[a] < distances[b] ? a : b);
      if (curr === end) break;
      queue.delete(curr);

      for (let neighbor in graph[curr]) {
        let alt = distances[curr] + graph[curr][neighbor];
        if (alt < distances[neighbor]) {
          distances[neighbor] = alt;
          prev[neighbor] = curr;
        }
      }
    }

    const path = [];
    let u = end;
    while (u) {
      path.unshift(u);
      u = prev[u];
    }
    return path;
  }

  // Nearest graph node
  function nearestNode(latlng) {
    let nearest = null, minDist = Infinity;
    for (let key in graph) {
      const [lat, lng] = key.split(',').map(Number);
      const dist = getDistance(latlng[0], latlng[1], lat, lng);
      if (dist < minDist) {
        minDist = dist;
        nearest = key;
      }
    }
    return nearest;
  }

  let routeLine = null;

  // On map click (user sets destination)
  map.on('click', function (e) {
    if (routeLine) map.removeLayer(routeLine);

    const endLatLng = [e.latlng.lat, e.latlng.lng];

    const startNode = nearestNode(defaultStart);
    const endNode = nearestNode(endLatLng);

    const routeKeys = dijkstra(startNode, endNode);
    const routeCoords = routeKeys.map(k => k.split(',').map(Number));

    routeLine = L.polyline(routeCoords, {
      color: 'blue',
      weight: 4
    }).addTo(map);
  });
</script>





</body>
</html>
